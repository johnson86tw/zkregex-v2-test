use zkregex::utils::{
   select_subarray,
   captures::capture_substring,
   sparse_array::SparseArray,
   transitions::check_transition_with_captures
};

global TRANSITION_TABLE: SparseArray<342, Field> = SparseArray {
    keys: [0x00000000, 0x00025250, 0x00025251, 0x00037574, 0x00041111, 0x00041212, 0x00041313, 0x00041414, 0x00041515, 0x00042828, 0x00044241, 0x0004888a, 0x0004888c, 0x0004898d, 0x00048a8e, 0x00048b8f, 0x00048c90, 0x00048d8e, 0x00048d91, 0x00048e92, 0x00048f93, 0x00049094, 0x00049195, 0x00049296, 0x0004a7ac, 0x0004a8a9, 0x0004b0b4, 0x0004b1b5, 0x0004b7bb, 0x0005cccb, 0x00068c91, 0x0006a6a7, 0x0007efec, 0x00089092, 0x00099394, 0x000af6f0, 0x000bf9f2, 0x000caab6, 0x000cb0ba, 0x000cb7bf, 0x000cbbca, 0x000cc1d1, 0x000ccedd, 0x000cd4d9, 0x000cf1e9, 0x000cf209, 0x000d9dab, 0x000d9ead, 0x000da5b3, 0x000da5b9, 0x000dadc1, 0x000db6c4, 0x000dc8cf, 0x000dc9d2, 0x000dc9d7, 0x000dc9de, 0x000dcddd, 0x000dced9, 0x000dcfde, 0x000df5ec, 0x000df60c, 0x000e9da3, 0x000ea1b4, 0x000ec0c8, 0x000ec7d5, 0x000ed1db, 0x000efbf1, 0x000efc11, 0x000f9fab, 0x000fc3c5, 0x000fc5c7, 0x000fc7c9, 0x000fc9cb, 0x000fcbcd, 0x000fcdcf, 0x000fcfd1, 0x000fd1d3, 0x000fd3d5, 0x000fd5d7, 0x0010a2a6, 0x0010a7b2, 0x0010b1bc, 0x0010b3be, 0x0010b9c4, 0x0010c0c4, 0x0010c3c9, 0x0010c5d0, 0x0010c5d6, 0x0010c7cb, 0x0010c9cf, 0x0010cdd1, 0x0010cdd9, 0x0010d1dc, 0x0010d5e0, 0x0010d9da, 0x0010dbdc, 0x0010dce3, 0x0010dde8, 0x001202f5, 0x00120315, 0x0012c9cb, 0x0013d0d1, 0x0013d7d8, 0x001509f9, 0x00150a19, 0x0015d1d2, 0x00171704, 0x00171724, 0x00181e0a, 0x00181e2a, 0x0018c0cb, 0x0019b6b8, 0x001acfd0, 0x001bc7cf, 0x001cced5, 0x001dd6dc, 0x001edbdc, 0x001fdbdf, 0x0020d7d8, 0x0021e0e2, 0x0022e3e4, 0x00243717, 0x00243737, 0x00247858, 0x00247878, 0x00247959, 0x00247979, 0x00247a5a, 0x00247a7a, 0x00247b5b, 0x00247b7b, 0x00247c5c, 0x00247c7c, 0x00247d5d, 0x00247d7d, 0x00247e5e, 0x00247e7e, 0x00247f5f, 0x00247f7f, 0x00248060, 0x00248080, 0x00248161, 0x00248181, 0x0024c8b2, 0x0024c8b7, 0x0024c8be, 0x0024c9b3, 0x0024c9b8, 0x0024c9bf, 0x0024cab4, 0x0024cab9, 0x0024cac0, 0x0024cbb5, 0x0024cbba, 0x0024cbc1, 0x0024ccb6, 0x0024ccbb, 0x0024ccc2, 0x0024cdb7, 0x0024cdbc, 0x0024cdc3, 0x0024ceb8, 0x0024cebc, 0x0024cebd, 0x0024cec4, 0x0024cfb9, 0x0024cfbd, 0x0024cfbe, 0x0024cfc5, 0x0024d0ba, 0x0024d0be, 0x0024d0bf, 0x0024d0c6, 0x0024d1bb, 0x0024d1bf, 0x0024d1c0, 0x0024d1c7, 0x0024d2c0, 0x0024d3c1, 0x0024d4c2, 0x0024d5c3, 0x0024d6c4, 0x0024d6d0, 0x0024d7c5, 0x0024d7d1, 0x0024d8c4, 0x0024d8c7, 0x0024d8c9, 0x0024d8ce, 0x0024d8d2, 0x0024d9c5, 0x0024d9c8, 0x0024d9ca, 0x0024d9cf, 0x0024d9d3, 0x0024dac6, 0x0024dac9, 0x0024dacb, 0x0024dad0, 0x0024dad4, 0x0024dbc7, 0x0024dbca, 0x0024dbcc, 0x0024dbd1, 0x0024dbd5, 0x0024dcc8, 0x0024dccb, 0x0024dccd, 0x0024dcd2, 0x0024dcd6, 0x0024ddc9, 0x0024ddcc, 0x0024ddce, 0x0024ddd3, 0x0024ddd7, 0x0024deca, 0x0024decd, 0x0024decf, 0x0024ded4, 0x0024ded8, 0x0024dfcb, 0x0024dfce, 0x0024dfd0, 0x0024dfd5, 0x0024dfd9, 0x0024e0cc, 0x0024e0cf, 0x0024e0d1, 0x0024e0d6, 0x0024e0da, 0x0024e1cd, 0x0024e1d0, 0x0024e1d2, 0x0024e1d7, 0x0024e1db, 0x0024e2d8, 0x0024e2dc, 0x0024e3d9, 0x0024e3dd, 0x0024e4da, 0x0024e4de, 0x0024e5db, 0x0024e5df, 0x0024e6dc, 0x0024e6e0, 0x0024e7dd, 0x0024e7e1, 0x0024e8d0, 0x0024e8de, 0x0024e8e2, 0x0024e9d1, 0x0024e9df, 0x0024e9e3, 0x0024ead2, 0x0024eae0, 0x0024eae4, 0x0024ebd3, 0x0024ebe1, 0x0024ebe5, 0x0024ecd4, 0x0024ece6, 0x0024edd5, 0x0024ede7, 0x0024eed6, 0x0024eed9, 0x0024eee8, 0x0024efd7, 0x0024efda, 0x0024efe9, 0x0024f0d8, 0x0024f0db, 0x0024f0ea, 0x0024f1d9, 0x0024f1dc, 0x0024f1eb, 0x0024f2dd, 0x0024f2ec, 0x0024f3de, 0x0024f3ed, 0x0024f4df, 0x0024f4ee, 0x0024f5e0, 0x0024f5ef, 0x0024f6e1, 0x0024f6f0, 0x0024f7e2, 0x0024f7f1, 0x0024f8e1, 0x0024f8e9, 0x0024f8f2, 0x0024f9e2, 0x0024f9ea, 0x0024f9f3, 0x0024f9f5, 0x0024fae3, 0x0024faeb, 0x0024faf4, 0x0024faf6, 0x0024fbe4, 0x0024fbec, 0x0024fbf5, 0x0024fbf7, 0x0024fce5, 0x0024fced, 0x0024fcf6, 0x0024fcf8, 0x0024fde6, 0x0024fdee, 0x0024fdf7, 0x0024fdf9, 0x0024fee7, 0x0024feef, 0x0024fef3, 0x0024fef8, 0x0024fefa, 0x0024ffe8, 0x0024fff0, 0x0024fff4, 0x0024fff9, 0x0024fffb, 0x002500e9, 0x002500f1, 0x002500f5, 0x002500fa, 0x002500fc, 0x002501ea, 0x002501f2, 0x002501f6, 0x002501fb, 0x002501fd, 0x002502f7, 0x002502fc, 0x002502fe, 0x002503f8, 0x002503fd, 0x002504f9, 0x002504fe, 0x002505fa, 0x002505ff, 0x002506fb, 0x00250700, 0x002507fc, 0x00250801, 0x00254847],
    values: [0x00000000, 0x00000000, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000007, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000007, 0x00000001, 0x00000007, 0x00000005, 0x00000007, 0x00000005, 0x00000007, 0x00000005, 0x00000007, 0x00000005, 0x00000007, 0x00000005, 0x00000007, 0x00000005, 0x00000007, 0x00000005, 0x00000007, 0x00000005, 0x00000007, 0x00000005, 0x00000007, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000000],
    maximum: 0x00254847
};

pub global CAPTURE_1_MAX_LENGTH: u32 = 5;
pub global NUM_CAPTURE_GROUPS: u32 = 1;

/**
 * Constrains a start state to be valid
 * @dev start states are hardcoded in this function - "(start_state - {state})" for each start
 *      example: `(start_state - 0) * (start_state - 1) * (start_state - 2)` means 0, 1, or 2
 *      are valid first states
 * 
 * @param start_state - The start state of the NFA
 */
fn check_start_state(start_state: Field) {
    let valid_start_state = (start_state - 0) * (start_state - 1);
    assert(valid_start_state == 0, "Invalid start state");
}
    
/**
 * Constrains the recognition of accept_state being reached. If an aceppt state is reached,
 *      ensures asserted traversal path is valid
 * @dev accept states are hardcoded in this function - "(next_state - {state})" for each accept
 *      example: `(next_state - 19) * (next_state - 20) * (next_state - 21)` means 19, 20, or 21
 *      are valid accept states
 * 
 * @param next_state - The asserted next state of the NFA
 * @param haystack_index - The index being operated on in the haystack
 * @param asserted_match_length - The asserted traversal path length
 * @return - 0 if accept_state is reached, nonzero otherwise
 */
fn check_accept_state(
    next_state: Field,
    haystack_index: Field, 
    asserted_match_length: Field
) -> Field {
    // check if the next state is an accept state
    let accept_state_reached = (next_state - 36);
    let accept_state_reached_bool = (accept_state_reached == 0) as Field;

    // check if the haystack index is the asserted match length
    // should equal 1 since haystack_index should be 1 less than asserted_match)length
    let asserted_path_traversed = (asserted_match_length - haystack_index == 1) as Field;

    (1 - (accept_state_reached_bool * asserted_path_traversed))
}

/**
 * NoRegexRegex matching function
 * Regex: No:\\s*(\\d+)
 * @param in_haystack - The input haystack to search from
 * @param match_start - The start index in the haystack for the subarray to match from
 * @param match_length - The length of the subarray to extract from haystack
 * @param current_states - The current states of the NFA at each index in the match subarray
 * @param next_states - The next states of the NFA at each index in the match subarray
 * @param capture_group_<group>_ids - The ids of the capture groups in the match subarray
 * @param capture_group_<group>_starts - The start positions of the capture groups in the match subarray
 * @param capture_group_start_indices - The start indices of the capture groups in the match subarray
 * @return - tuple of substring captures as dictated by the regular expression
 */
pub fn regex_match<let MAX_HAYSTACK_LEN: u32, let MAX_MATCH_LEN: u32>(
    in_haystack: [u8; MAX_HAYSTACK_LEN],
    match_start: u32,
    match_length: u32,
    current_states: [Field; MAX_MATCH_LEN],
    next_states: [Field; MAX_MATCH_LEN],
    capture_group_1_id: [Field; MAX_MATCH_LEN],
    capture_group_1_start: [Field; MAX_MATCH_LEN],
    capture_group_start_indices: [Field; NUM_CAPTURE_GROUPS],
) -> (BoundedVec<u8, CAPTURE_1_MAX_LENGTH>) {
    // resize haystack 
    let haystack: [u8; MAX_MATCH_LEN] = select_subarray::<MAX_HAYSTACK_LEN, MAX_MATCH_LEN>(in_haystack, match_start, match_length);

    check_start_state(current_states[0]);
    for i in 0..MAX_MATCH_LEN-1 {
        // match length - 1 since current states should be 1 less than next states
        let in_range = (i < match_length - 1) as Field;
        let matching_states = current_states[i + 1] - next_states[i];
        assert(in_range * matching_states == 0, "Invalid Transition Input");
    }
    let mut reached_end_state = 1;
    for i in 0..MAX_MATCH_LEN {
        let active_capture_groups_at_index = [capture_group_1_id[i]];
        let active_capture_groups_starts_at_index = [capture_group_1_start[i]];
        check_transition_with_captures(
            TRANSITION_TABLE,
            haystack[i] as Field,
            current_states[i],
            next_states[i],
            active_capture_groups_at_index,
            active_capture_groups_starts_at_index,
            reached_end_state
        );
        reached_end_state = reached_end_state * check_accept_state(next_states[i], i as Field, match_length as Field);
    }
    assert(reached_end_state == 0, "Did not reach a valid end state");

    // Capture Group 1
    let capture_1 = capture_substring::<MAX_MATCH_LEN, CAPTURE_1_MAX_LENGTH, 1>(
       haystack,
       capture_group_1_id,
       capture_group_1_start,
       capture_group_start_indices[0]
    );

    (capture_1)
}

